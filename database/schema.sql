-- TruthGuard AI - Database Schema

-- 1. Custom ENUM Types for status fields
-- This provides type safety at the database level.
CREATE TYPE content_type AS ENUM ('text', 'url', 'image', 'video');
CREATE TYPE claim_status AS ENUM ('pending', 'processing', 'completed', 'failed');
CREATE TYPE verdict_type AS ENUM ('true', 'false', 'misleading', 'uncertain');
CREATE TYPE vote_type AS ENUM ('up', 'down');
CREATE TYPE rti_status AS ENUM ('draft', 'submitted', 'responded', 'closed');

-- 2. User Profiles Table
-- Stores public user data. Synced with the auth.users table.
CREATE TABLE IF NOT EXISTS public.user_profiles (
    id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE,
    full_name TEXT,
    avatar_url TEXT,
    cover_photo_url TEXT,
    is_expert BOOLEAN DEFAULT FALSE NOT NULL,
    expert_domain TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);
COMMENT ON TABLE public.user_profiles IS 'Public profile information for each user.';

-- 3. Claims Table
-- Core table for all fact-checking claims.
CREATE TABLE IF NOT EXISTS public.claims (
    id uuid DEFAULT gen_random_uuid() NOT NULL PRIMARY KEY,
    user_id uuid NOT NULL REFERENCES public.user_profiles(id) ON DELETE SET NULL,
    content TEXT NOT NULL,
    content_type content_type NOT NULL,
    original_url TEXT,
    file_path TEXT, -- Path in Supabase Storage
    status claim_status DEFAULT 'pending' NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);
COMMENT ON TABLE public.claims IS 'Fact-checking claims submitted by users.';
-- Add indexes for faster queries
CREATE INDEX ON public.claims (user_id);
CREATE INDEX ON public.claims (status);

-- 4. Claim Analyses Table
-- Stores the results from the AI fact-checking service.
CREATE TABLE IF NOT EXISTS public.claim_analyses (
    id uuid DEFAULT gen_random_uuid() NOT NULL PRIMARY KEY,
    claim_id uuid NOT NULL UNIQUE REFERENCES public.claims(id) ON DELETE CASCADE,
    verdict verdict_type NOT NULL,
    confidence_score REAL NOT NULL,
    summary TEXT NOT NULL,
    evidence JSONB,
    sources JSONB,
    ai_reasoning TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);
COMMENT ON TABLE public.claim_analyses IS 'AI-generated analysis of a claim.';
CREATE INDEX ON public.claim_analyses (claim_id);

-- 5. Claim Comments Table
-- For community discussion on claims.
CREATE TABLE IF NOT EXISTS public.claim_comments (
    id uuid DEFAULT gen_random_uuid() NOT NULL PRIMARY KEY,
    claim_id uuid NOT NULL REFERENCES public.claims(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES public.user_profiles(id) ON DELETE CASCADE,
    content TEXT NOT NULL,
    upvotes INT DEFAULT 0 NOT NULL,
    downvotes INT DEFAULT 0 NOT NULL,
    is_expert_response BOOLEAN DEFAULT FALSE NOT NULL,
    parent_comment_id uuid REFERENCES public.claim_comments(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);
COMMENT ON TABLE public.claim_comments IS 'User comments on a specific claim.';
CREATE INDEX ON public.claim_comments (claim_id);
CREATE INDEX ON public.claim_comments (user_id);

-- 6. Comment Votes Table
-- Tracks user votes on comments to prevent duplicate voting.
CREATE TABLE IF NOT EXISTS public.comment_votes (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    comment_id uuid NOT NULL REFERENCES public.claim_comments(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES public.user_profiles(id) ON DELETE CASCADE,
    vote_type vote_type NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    UNIQUE(comment_id, user_id) -- Ensures a user can only vote once per comment
);
COMMENT ON TABLE public.comment_votes IS 'Tracks upvotes and downvotes on comments.';

-- 7. RTI Requests Table
CREATE TABLE IF NOT EXISTS public.rti_requests (
    id uuid DEFAULT gen_random_uuid() NOT NULL PRIMARY KEY,
    claim_id uuid NOT NULL REFERENCES public.claims(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES public.user_profiles(id) ON DELETE CASCADE,
    reason TEXT NOT NULL,
    status rti_status DEFAULT 'draft' NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);
COMMENT ON TABLE public.rti_requests IS 'Right to Information requests related to claims.';
CREATE INDEX ON public.rti_requests (claim_id);
CREATE INDEX ON public.rti_requests (user_id);

-- 8. Helper Function to automatically update `updated_at` timestamps
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 9. Triggers to call the function on table updates
CREATE TRIGGER on_claims_update BEFORE UPDATE ON public.claims FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
CREATE TRIGGER on_profiles_update BEFORE UPDATE ON public.user_profiles FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
CREATE TRIGGER on_comments_update BEFORE UPDATE ON public.claim_comments FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
CREATE TRIGGER on_rti_update BEFORE UPDATE ON public.rti_requests FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();

-- 10. Supabase Storage Bucket for file uploads
INSERT INTO storage.buckets (id, name, public)
VALUES ('claim_files', 'claim_files', true)
ON CONFLICT (id) DO NOTHING;

-- 11. Row Level Security (RLS) Policies
-- This is crucial for securing your data.

-- Enable RLS for all tables
ALTER TABLE public.user_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.claims ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.claim_analyses ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.claim_comments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.comment_votes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.rti_requests ENABLE ROW LEVEL SECURITY;

-- Policies for user_profiles
CREATE POLICY "Users can view all profiles." ON public.user_profiles FOR SELECT USING (true);
CREATE POLICY "Users can insert their own profile." ON public.user_profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update their own profile." ON public.user_profiles FOR UPDATE USING (auth.uid() = id);

-- Policies for claims
CREATE POLICY "Anyone can view claims." ON public.claims FOR SELECT USING (true);
CREATE POLICY "Authenticated users can create claims." ON public.claims FOR INSERT WITH CHECK (auth.role() = 'authenticated');
CREATE POLICY "Users can update their own claims." ON public.claims FOR UPDATE USING (auth.uid() = user_id);

-- Policies for claim_analyses
CREATE POLICY "Anyone can view claim analyses." ON public.claim_analyses FOR SELECT USING (true);
-- Analyses are only created by the service role key, so no INSERT policy needed for users.

-- Policies for comments and votes
CREATE POLICY "Anyone can read comments." ON public.claim_comments FOR SELECT USING (true);
CREATE POLICY "Authenticated users can create comments." ON public.claim_comments FOR INSERT WITH CHECK (auth.role() = 'authenticated');
CREATE POLICY "Users can update their own comments." ON public.claim_comments FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own comments." ON public.claim_comments FOR DELETE USING (auth.uid() = user_id);

CREATE POLICY "Anyone can read votes." ON public.comment_votes FOR SELECT USING (true);
CREATE POLICY "Authenticated users can vote." ON public.comment_votes FOR INSERT WITH CHECK (auth.role() = 'authenticated');
CREATE POLICY "Users can change/delete their own votes." ON public.comment_votes FOR ALL USING (auth.uid() = user_id);

-- Policies for rti_requests
CREATE POLICY "Users can view their own RTI requests." ON public.rti_requests FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can create RTI requests." ON public.rti_requests FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own RTI requests." ON public.rti_requests FOR UPDATE USING (auth.uid() = user_id);